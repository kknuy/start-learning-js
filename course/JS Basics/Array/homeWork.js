/* 
Задание #1
Представьте, что мы разрабатываем систему очередей для какого-либо заведения.
Например, для почты. Для этого мы создали массив peopleWaiting, который отображает
текущий статус очереди.
const peopleWaiting = ['Кристина', 'Олег', 'Кирилл', 'Мария',
'Светлана', 'Артем', 'Глеб'];
По логике, следующую посылку по почте получит Кристина, после нее уже 1-м в очереди
будет Олег.
Сейчас вам необходимо реализовать следующую логику в коде шаг за шагом:
1. Кристина и Олег получили посылки и ушли из очереди. Вам необходимо удалить их
из массива.
2. Теперь подошла очередь к Кириллу. И неожиданно сотрудница почты говорит, что
скоро у них обеденный перерыв и она успеет обслужить только Кирилла. Поэтому
все остальные люди, стоящие за Кириллом, решили не ждать, когда закончится
обед и просто ушли из отделения почты. Вам необходимо сначала удалить
Кирилла из массива peopleWaiting, а затем удалить людей, которые не успели
получить посылки.
Когда какой-либо человек получает посылку, необходимо вывести в модальном окне
сообщение “name получил(а) посылку. В очереди осталось length человек.” (Замените
name на имя человека, получившего посылку, а length - на количество человек, которые
остались в очереди).
Если же человек не получил посылку и ушел из очереди, то выведите в модальном окне
через alert сообщение “name не получил(а) посылку и ушел(ла) из очереди”.
Рекомендуется создать 2 функции: giveParcel - для выдачи посылки и удаления клиента
из начала массива, leaveQueueWithoutParcel - для удаления клиента, который не
получил посылку из конца списка.
*/

const giveParcel = (name , length) => {
    console.log(`${name} получил(а) посылку. В очереди осталось ${length} человек.`) ;
};

const leaveQueueWithoutParcel = (name) => {
    console.log( `${name} не получил(а) посылку и ушел(ла) из очереди`);
};

const peopleWaiting = ['Кристина', 'Олег', 'Кирилл', 'Мария','Светлана', 'Артем', 'Глеб'];


while (peopleWaiting.length > 0) {
    giveParcel(peopleWaiting[0], peopleWaiting.length-1);
    peopleWaiting.shift();
    if (peopleWaiting[0] === 'Кирилл') {
        console.log("У нас обед последний человек");
        giveParcel(peopleWaiting[0], peopleWaiting.length-1);
        peopleWaiting.shift();
        while (peopleWaiting.length > 0) {
            leaveQueueWithoutParcel(peopleWaiting[0], peopleWaiting.length-1);
            peopleWaiting.shift();
        }
    }
};


/* 
Задание #2
Вам необходимо создать функцию getSumOfSequence, которая будет создавать массив
из чисел и высчитывать сумму первого и последнего элементов массива.
Функция принимает в себя один параметр number. Используя этот параметр, нужно
создать массив из чисел от 1 до number. Для заполнения массива элементами
используйте цикл for. (Например, если был передан number равный 5, то массив должен
выглядеть следующим образом: [1, 2, 3, 4, 5])
Функция getSumOfSequence должна возвращать сумму первого и последнего элементов
итогового массива.
Пример:
getSumOfSequence(5) = 6 // [1, 2, 3, 4, 5], 1+5=6
*/

const getSumOfSequence = (nubmer) => {
    let arr = [];
    for (let i = 1; i <= nubmer; i++) {
        arr.push(i);
    };
    console.log("Sum first and last elements of sequence :", arr[0] + arr[arr.length-1]);
    return arr;
};

console.log(getSumOfSequence(5));


/* 
Задание #3
Представьте, что у вас есть друг Алексей, который является владельцем кофейни. Он
хочет сделать сайт для этой кофейни, чтобы люди могли заказывать доставку кофе на
дом. Самая главная функция, которую хочет видеть Алексей, это поиск кофе по названию.
Ваш друг просит вас помочь ему с разработкой сайта.
Изначально у вас есть массив coffees, в котором хранятся все виды кофе, которые есть в
кофейне у Алексея. Напитки распределены в порядке популярности среди клиентов. Т.е.
кофе “Latte” - самый популярный.
const coffees = ['Latte', 'Cappuccino', 'Americano'];
С помощью функции prompt вам необходимо запрашивать название кофе. Передайте в
prompt сообщение “Поиск кофе по названию:”. Сохраните значение, которое ввел
пользователь в переменную coffeeName.
Если введенное пользователем название кофе существует, то отобразите сообщение с
помощью alert “Держите ваш любимый кофе coffee. Он number-й по популярности в
нашей кофейне.”, где coffee - название найденного кофе, number - номер найденного кофе
в массиве coffees. Если же кофе не был найден, то отобразите сообщение “К сожалению,
такого вида кофе нет в наличии”.
Условия:
1. Название кофе должно быть регистронезависимым. Т.е. если пользователь
напечатает “lATte”, то должен показаться результат с кофе “Latte”
2. Необходимо использовать findIndex.
*/
// const coffees = ['Latte', 'Cappuccino', 'Americano'];

// let coffeeName = prompt('Поиск кофе по названию:');

// if(coffeeName){
//     let index = coffees.findIndex((coffe,index) => {
//         if(coffe.toLowerCase() === coffeeName.toLowerCase().trim())
//         return true;
//     });
//     if(index !== -1){
//         alert(`Держите ваш любимый кофе ${coffees[index]}. Он ${index+1} по популярности в нашей кофейне.`);
//     } else {
//         alert("К сожалению, такого вида кофе нет в наличии");
//     }
// } else {
//     alert("К сожалению, такого вида кофе нет в наличии");
// }



/* 
Задание #4
Вы разработали главную функциональность, которую хотел видеть Алексей на своем
сайте. Он говорит вам большое спасибо, потому что благодаря сайту в кофейне
увеличилось количество продаж. Теперь Алексей захотел поднять цену на кофе, чтобы
прибыли было еще больше.
У вас изначально есть 2 массива: coffees (хранит названия кофе) и prices (хранит цены на
кофе). Индексы для названий кофе и цен взаимосвязаны. Т.е. “Latte” стоит 1.5 евро,
“Cappuccino” - 1 евро, и т.д.
const coffees = ['Latte', 'Cappuccino', 'Americano'];
const prices = [1.5, 1, 2];
Вам необходимо создать новый массив updatedPrices, который будет содержать те же
числа из массива prices, но только увеличенные на 0.5.
После подъема цен вам необходимо уведомить об этом клиентов кофейни, поэтому
выведите для каждого типа кофе сообщение через alert “Кофе name сейчас стоит price
евро”, где name - название кофе, а price - обновленная цена на кофе.
Условия:
1. Необходимо использовать методы массивов map и forEach
*/

const coffees = ['Latte', 'Cappuccino', 'Americano'];
const prices = [1.5, 1, 2];

const updatedPrices = prices.map((oldPrice) => {
   return  oldPrice + 0.5;
});

coffees.forEach((coffe,index) => {
    alert(`Кофе ${coffe} сейчас стоит ${updatedPrices[index]} евро`);
});


/* 
Задание #5
Последнее, что хочет видеть Алексей на своем сайте - это система оценок работы
кофейни. Владельцу необходимо знать мнение клиентов, чтобы исправлять недочеты в
своей работе.
Для начала вам необходимо создать пустой массив clientsEstimations, в котором будут
хранится оценки клиентов кофейни. Также создайте функцию
askClientToGiveEstimation, которая должна выводить сообщение “Как вы оцениваете
нашу кофейню от 1 до 10?” через prompt. Конечный результат, который введет
пользователь, должен быть типом данных number. Если было введено число от 1 до 10, то
добавьте эту оценку в массив clientsEstimations, иначе же никаких действий не
совершайте.
Для добавления оценок вызовите функцию askClientToGiveEstimation 5 раз.
Рекомендуется это сделать через цикл for.
После того, как оценки будут добавлены, вам необходимо посчитать положительные и
отрицательных оценки. Положительной оценкой является число больше 5, отрицательной
- число, меньшее за 5 либо равное 5. Выведите через alert сообщение “Всего
положительных оценок: goodEstimations; Всего отрицательных оценок:
notGoodEstimations”, где goodEstimations - количество положительных оценок, а
notGoodEstimations - количество отрицательных оценок.
Условия:
1. В решение должен быть использован метод массивов filter.
*/

const clientsEstimations = [];

const askClientToGiveEstimation = () => {
    let markClient = Number(prompt('Как вы оцениваете нашу кофейню от 1 до 10?'));
    if (markClient >= 1 && markClient <= 10) {
        clientsEstimations.push(markClient);
    }
};


let goodEstimations = 0;
let notGoodEstimations = 0;

for (let i = 0; i < 5; i++) {
    askClientToGiveEstimation();
}
    clientsEstimations.filter((mark) => {
        if (mark > 5) {
            goodEstimations++;
        } else if (mark <= 5) {
            notGoodEstimations++;
        }
    });

    alert(`Всего положительных оценок: ${goodEstimations}; Всего отрицательных оценок:${notGoodEstimations}`);